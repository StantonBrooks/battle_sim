# **Recommendations for Simulating Large-Scale Unarmed Combat Scenarios**

## **I. Introduction**

### **Purpose and Scope**

This report provides research-driven recommendations to guide the development and execution of a large-scale combat simulation. The specific scenario involves 100 unarmed combatant entities engaging against a single, similarly unarmed entity within a confined environment. The simulation aims to determine the statistically probable victor across 11,000 simulation runs, employing two distinct methodologies: 1,000 runs orchestrated using Large Language Models (LLMs) and 10,000 runs executed via a custom-developed Command Line Interface (CLI) script.  
The primary objectives of this report are twofold:

1. To establish best practices for defining the Rules of Engagement (RoE) governing the combat simulation. These practices must ensure applicability and consistency across both the LLM and custom script simulation methods. This includes the delivery of a practical RoE battle sheet template to standardize simulation parameters.  
2. To recommend an optimal programming language for developing the custom CLI script, prioritizing factors relevant to large-scale simulation, such as performance, reliability, and development efficiency.

The scope is constrained by specific parameters outlined in the simulation requirements: combatants are unarmed, possess characteristics defined by pre-existing character sheets, are confined to a finite, inescapable arena (compelling combat as the sole option), and are driven to engage without exception. The simulation should be considered abstractly applicable across various global locations, implying environmental factors beyond the arena's basic structure are likely negligible or standardized. The goal is to leverage modeled statistics to predict combat outcomes. This report focuses solely on the preparatory research and recommendations for RoE design and language selection; it does not encompass the actual implementation or execution of the simulations.

### **Simulation Context**

Combat simulation serves as a powerful tool for analyzing complex dynamic systems, offering insights into scenarios that are difficult or impossible to study through direct experimentation. Its applications range from military strategy and defense analysis 1 to understanding market dynamics and epidemic spread.3 By modeling the interactions of individual components, simulations can reveal emergent system-level behaviors and predict outcomes under various conditions.1  
The specific scenario presented—a 100 vs 1 unarmed engagement—poses unique challenges. It requires modeling the potentially chaotic interactions of a large group against a single opponent, where factors like spatial constraints, targeting logic, and the aggregate effect of numerous individual actions become critical. The dual-method approach, utilizing both sophisticated LLMs and a high-volume custom script, necessitates a framework that ensures consistency and comparability between the results generated by these different techniques. LLMs offer potential for nuanced behavioral representation, while the custom script allows for high-throughput, statistically robust analysis through repeated runs.4

### **Methodology**

This report synthesizes findings from research into computational modeling paradigms, specifically Agent-Based Modeling (ABM), unarmed combat mechanics derived from gaming and simulation literature, principles of character attribute quantification, and comparative analysis of programming languages suitable for simulation development. The methodology involves:

1. Identifying ABM as the most appropriate modeling framework for this scenario.  
2. Analyzing best practices for defining agent attributes based on character sheets and interaction rules for unarmed combat.  
3. Developing a structured RoE framework applicable to both LLM prompts and scripted implementation.  
4. Evaluating candidate programming languages based on performance, development considerations, ecosystem support, scalability, and reliability for the high-volume scripted simulation.  
5. Formulating actionable recommendations supported by evidence from the reviewed sources.

The emphasis throughout is on providing practical, justified guidance to ensure the simulation's accuracy, efficiency, and relevance to the user's goal of statistical outcome prediction.

### **Relevance of Agent-Based Modeling (ABM)**

Agent-Based Modeling (ABM) emerges as the most suitable computational paradigm for simulating the proposed 100 vs 1 combat scenario. Unlike traditional mathematical models that often treat forces as aggregates, ABM adopts a bottom-up approach, simulating individual combatants as autonomous or semi-autonomous agents.1 Each entity (agent) possesses distinct characteristics (attributes) and follows specific behavioral rules, making decisions based on its internal state, the local environment, and interactions with other agents.1  
This approach is particularly well-suited for capturing the complexity inherent in the interaction of numerous entities.3 ABM excels at revealing emergent behaviors—system-level patterns and outcomes that arise spontaneously from the interactions of individual agents but cannot be easily predicted by analyzing the components in isolation.1 Understanding how the group of 100 might coordinate, interfere with each other, or apply collective pressure against the single opponent requires a model capable of simulating these micro-level interactions and observing the resulting macro-level dynamics. ABM provides the necessary framework to explore these phenomena, offering a higher degree of realism compared to top-down, aggregate models, especially when modeling adaptive or heterogeneous entities.1

## **II. Modeling Combatants and Interactions: An Agent-Based Approach**

### **A. The Rationale for Agent-Based Modeling (ABM)**

The selection of Agent-Based Modeling (ABM) as the foundational approach for this simulation is driven by its unique capabilities in handling scenarios characterized by numerous, interacting, autonomous entities, which aligns perfectly with the 100 vs 1 combat setup.1  
**Capturing Complexity:** ABM is fundamentally designed to model systems composed of multiple agents that operate and interact simultaneously.4 In the context of the 100 vs 1 battle, each combatant can be represented as an agent. ABM allows each agent to possess its own set of properties (derived from character sheets) and behavioral rules (defined by the RoE).5 Agents make decisions and take actions based on their perception of the environment (the arena, the location of other agents) and their interactions (being attacked, proximity to targets).1 This granular level of detail provides a richer, more realistic simulation of the complex dynamics at play compared to aggregate models that might treat the group of 100 as a monolithic entity.  
**Emergent Behavior:** A key strength of ABM is its ability to capture emergence – the arising of complex, system-level patterns from the relatively simple interactions of individual agents.1 In the 100 vs 1 scenario, the overall outcome is not merely the sum of individual capabilities but depends heavily on how the agents interact spatially and temporally. For instance, how effectively can the 100 agents bring their numbers to bear against the single opponent? Do they hinder each other due to crowding? Does the single opponent get overwhelmed quickly, or can it exploit positioning to mitigate the numerical disadvantage? These are emergent properties of the system that ABM is well-suited to explore. The simulation can reveal patterns that wouldn't be obvious from analyzing a single agent's characteristics alone.1  
**Heterogeneity and Adaptation:** ABM readily accommodates heterogeneity among agents.3 If the character sheets define different strengths, speeds, or endurance levels for the 100 entities, ABM can represent each agent with its unique attribute values. While the "compelled to engage" constraint simplifies agent motivation, ABM frameworks can, in principle, model adaptive behaviors where agents might change their tactics based on experience or changing conditions.1 For this specific simulation, while complex adaptation might be computationally prohibitive, the inherent ability to handle diverse agent characteristics derived from the character sheets is crucial for accurately representing the initial conditions.  
Furthermore, the bottom-up nature of ABM intrinsically supports the user's goal of running numerous simulations for statistical analysis. Because the system's behavior emerges from individual agent rules and interactions, modifying these parameters—such as varying agent attributes based on character sheet distributions or tweaking RoE parameters—is straightforward.1 Running thousands of simulations (Monte Carlo methods, as mentioned in 4) with slight variations in initial conditions or rules allows for robust exploration of the parameter space and sensitivity analysis. This directly enables the generation of the "modeled statistics" required to answer the core question of which side is likely to win under the specified conditions. The design of agent attributes and the RoE must, therefore, facilitate this parameterization to fully leverage ABM's potential for large-scale "what-if" analysis.

### **B. Defining Combatant Agents: Attributes and Properties**

Translating the qualitative and quantitative information from existing character sheets into a functional set of agent attributes for the simulation is a critical first step. This process requires careful consideration to ensure the attributes are relevant to unarmed combat, computationally tractable, and consistently interpretable by both the LLM and the custom script.  
**Translating Character Sheets:** Character sheets often contain a mix of numerical stats, skills, and descriptive text. The simulation requires quantifiable attributes.6 This involves identifying the core characteristics relevant to unarmed combat and mapping them to numerical scales. For example, descriptions like "very strong" or "quick reflexes" must be translated into numerical values for Strength and Speed/Agility, respectively. Establishing clear mapping rules is essential for consistency.  
**Essential Unarmed Combat Attributes:** Based on common practices in RPG design and combat simulation, a core set of attributes is recommended.6 These form the basis of the agent's state and capabilities:

* **Health Points (HP) / Endurance / Constitution:** Represents the agent's ability to withstand damage before being incapacitated or killed. This is a fundamental stat in virtually all combat simulations.6 It is typically a mutable property, decreasing as the agent takes damage.5  
* **Strength / Might / Force:** Determines the physical power of the agent, directly influencing the damage dealt by unarmed attacks.6 This is usually an immutable base attribute, though temporary modifiers could exist.  
* **Speed / Agility / Dexterity:** Represents the agent's quickness, reflexes, and coordination. This attribute typically influences turn order (initiative), the chance to successfully hit an opponent, the chance to dodge incoming attacks, and movement speed within the arena.6  
* **Defense / Toughness / Vigor:** Represents the agent's inherent ability to resist or mitigate incoming damage, separate from dodging. This could be linked to Constitution or be a distinct attribute affecting damage reduction.6  
* **Size / Reach:** While less common as a primary stat, the physical size of the combatants might influence factors like movement, reach for attacks, and success in grappling maneuvers.13 This may be implicitly handled or explicitly defined.  
* **(Optional) Fatigue:** Represents the agent's stamina. As agents exert themselves through actions like attacking or moving, fatigue could accumulate, potentially imposing penalties on their performance over time.8 Implementing fatigue adds realism but increases simulation complexity.

**Attribute Design Principles:** When defining these attributes, several principles should guide the process. Attributes should be *relevant* to the simulation's core mechanics (unarmed combat).6 They should ideally be *exclusive* or orthogonal, representing distinct aspects of the agent to avoid redundancy.7 The set of attributes should be *balanced*, ensuring each plays a meaningful role.7 Finally, they should be *evocative*, allowing the user to relate the numerical values back to the conceptual character.7 A critical trade-off exists between *granularity* and *simplicity*. More attributes can increase realism but also increase computational load and the complexity of LLM interpretation.6 Given the scale of the simulation (101 agents, 10,000+ runs), simplicity is often preferred.  
**Agent Properties (ABM Context):** In ABM terms, these combat attributes become the agent's properties.5 It's important to define whether each property is *mutable* (changes during a simulation run, like HP or Fatigue) or *immutable* (fixed for the duration of a run, like base Strength or Speed).5 Consideration should also be given to *observability*: which properties can other agents perceive? Agents can likely observe approximate HP (visible injury) or position, but not precise internal stats like remaining fatigue or exact Strength value.5  
The level of abstraction chosen for these attributes is paramount for ensuring compatibility between the LLM and scripted simulation methods. LLMs might theoretically handle more nuanced or narrative descriptions 1, but validating their consistent interpretation is difficult. The scripted simulation, conversely, demands concrete, numerical parameters.6 Therefore, the attributes defined must be sufficiently abstract and clearly quantifiable to serve as a common ground. Ambiguous or overly complex attributes risk causing the two simulation methods to diverge, undermining the goal of comparative analysis. The RoE Battle Sheet (Section IV) must meticulously define each attribute, its numerical scale, and its mechanical effect, acting as the definitive specification for both LLM prompting and script implementation.

### **C. Agent Interactions and Environment**

The behavior of the simulation emerges not only from agent attributes but also from how agents interact with each other and their environment.1  
**Interaction Topology:** The simulation environment is defined as a finite, inescapable arena. This establishes the spatial boundaries for agent movement and interaction. The interaction topology is dynamic, determined by the agents' positions within this space. Agents primarily interact when within melee range (e.g., adjacent grid cells or within a specific distance, often modeled as 5 feet in RPG contexts 15). The network of potential interactions changes constantly as agents move.4  
**Agent Actions:** Agents perform actions that alter their own state, the state of other agents, or potentially the environment (though the latter is less relevant in a static arena).5 Key actions in unarmed combat include:

* *Movement:* Changing position within the arena, governed by Speed/Agility and constrained by boundaries and other agents.  
* *Attack (Strike):* Attempting to inflict damage on an opponent using unarmed blows (punches, kicks, etc.).15  
* *Defend:* Taking actions to improve survivability, such as dodging or blocking, potentially at the cost of offensive action.12  
* *Grapple:* Attempting to seize and control an opponent, potentially immobilizing or damaging them.13 This adds significant complexity, especially with multiple potential grapplers.

**Decision-Making Heuristics:** Agents require rules to determine their actions each turn. The "compelled to engage" constraint simplifies motivation, but tactical choices remain. Key decision points include:

* *Target Selection:* How do agents choose whom to attack? For the 100 agents, the choice is simple: the single opponent. For the single opponent facing 100, rules are needed. Options include attacking the nearest agent, a randomly chosen agent within reach, or perhaps the agent with the lowest perceived HP. Simple, deterministic, or minimally stochastic rules are essential for computational tractability in the script. Concepts from military command and control (C2) like task allocation or concentration of force 18 provide context but are likely too complex to implement directly; simplified heuristics are necessary. The Information Age Combat Model's (IACM) node interactions (sense, decide, influence) offer a conceptual parallel for agent action cycles.19  
* *Action Selection:* Based on the agent's state (HP, fatigue, proximity to enemies/allies), which action should it take? Attack if an enemy is in range? Move closer if not? Use a defensive action if low on HP? Again, simple rules are needed.

**Environment:** The primary environmental element is the arena itself: its finite size and inescapable walls. The user's specification that simulations run in "multiple random locations around the globe" suggests that specific environmental details (terrain features, weather 18) are likely abstracted out or standardized, ensuring results are generalizable and not dependent on specific location characteristics beyond the basic arena structure.  
Implementing sophisticated artificial intelligence or group tactics for 100 agents across 10,000 runs presents significant computational challenges and validation difficulties.1 The "compelled to engage" rule simplifies the 'why' of fighting, but the 'how' (tactics) remains. Therefore, the decision logic for the scripted simulation must be kept simple (e.g., "move towards the enemy," "attack if in range," "target nearest"). LLMs might potentially generate more complex or seemingly strategic behavior, but this behavior will be less predictable, harder to replicate statistically, and difficult to validate against a defined ruleset.1 This necessary simplification in the scripted simulation reduces behavioral realism compared to real-world combat or more advanced AI models. The RoE must clearly define these simple decision rules, and the potential variance in behavioral complexity between the LLM and script runs should be acknowledged as a factor influencing the results.

## **III. Best Practices for Unarmed Combat Rules of Engagement (RoE)**

Developing a clear, consistent, and computationally feasible set of Rules of Engagement (RoE) is crucial for the success of the simulation project. The RoE must structure the combat flow, define the mechanics of unarmed interaction, account for environmental and group factors, and be equally applicable to both the LLM-driven and scripted simulation approaches.

### **A. Structuring the Combat Flow**

The temporal progression and action framework of the simulation need careful definition.  
**Time Advancement:** The simulation will inherently operate based on principles of Discrete-Event Simulation (DES), where the system state changes at discrete points in time.20 While pure DES often uses a next-event time advance (jumping the clock to the time of the next scheduled event) 23, a time-stepped or round-based approach is more common and practical for turn-based combat simulations, as seen in many RPGs.14 This involves advancing the simulation clock in fixed increments (rounds), during which agents take their turns. Defining the simulated duration of a round (e.g., 1-6 seconds) provides context.14 Given the large number of agents and runs, a round-based system offers a good balance between granularity and computational manageability. All digital simulations are ultimately discrete.24  
**Initiative and Turn Order:** A mechanism is needed to determine the order in which agents act each round. Common methods include:

* Ordering agents based on a Speed or Agility attribute, typically from highest to lowest.6 This is deterministic and computationally simple.  
* Introducing randomness, either by rolling for initiative each round or adding a random element to the Speed score. This increases stochasticity but adds computational overhead.  
* Using group initiative for the 100 agents versus individual initiative for the single agent. This simplifies managing the large group but might obscure individual speed differences within the group. RPG systems offer various examples.14 For efficiency and simplicity, **a fixed turn order based on the Speed attribute is recommended.**

**Action Economy:** This defines the set of actions an agent can perform during its turn.14 Systems vary in complexity:

* Dungeons & Dragons-like systems often use a structure of Action, Bonus Action, and Movement.15  
* Some systems use action points, where different actions consume varying numbers of points from a pool allocated each round.14  
* Simpler models might allow only one major action (e.g., Attack or Defend) plus Movement per turn. For large-scale simulation, **a simple action economy, such as allowing one Movement action and one Combat Action (e.g., Strike, Defend, Grapple) per turn, is recommended.** This structure is easier to implement consistently in both the script and LLM prompts.

The chosen structure for time advancement, initiative, and action economy directly influences the simulation's granularity and computational performance. More complex systems (e.g., shorter time steps, intricate action point systems 14) offer potentially higher fidelity but significantly increase the number of calculations required per simulated second.23 With 101 agents and 10,000+ runs, computational cost is a major concern. Therefore, adopting a streamlined, round-based structure with a simple action economy provides the necessary balance between representing the combat dynamics and ensuring the simulation remains computationally feasible. While LLMs might handle slightly more complex narrative instructions, maintaining consistency across both methods favors adopting the simpler structure universally.

### **B. Mechanics of Unarmed Combat**

The core of the RoE lies in defining how unarmed combat actions are resolved.  
**Attack Actions:** While real unarmed combat involves diverse techniques 15, for simulation purposes, these can be abstracted. Options include:

* A single generic 'Strike' action representing any unarmed attack.  
* Categorizing attacks (e.g., 'Light Strike', 'Heavy Strike') with different damage, accuracy, or speed implications.  
* Specific named attacks (Punch, Kick, Headbutt 15) if differentiation is desired, though this adds complexity. **A single 'Strike' action is recommended for simplicity.**

**Attack Resolution:** Determining whether an attack hits its target requires a clear mechanic. Common approaches include:

* An attack roll (e.g., on a 20-sided die, d20) plus attribute modifiers versus a target's static Defense Class (DC) or Armor Class (AC).12  
* An opposed roll, where both attacker and defender roll dice modified by relevant skills or attributes.13  
* A percentage-based chance to hit, calculated from the attacker's accuracy (derived from Speed/Agility) and the defender's evasiveness (also potentially Speed/Agility based). Given the need for computational efficiency over 10,000 runs, **a percentage-based hit chance calculation is recommended.** Formula example: Phit​=BaseHit%+(AttackerSpeedMod−DefenderSpeedMod)×Modifier%.

**Damage Calculation:** If an attack hits, the damage inflicted must be calculated. Options include:

* Fixed base damage modified by the attacker's Strength/Might attribute.  
* Variable damage, often represented by a dice roll (e.g., 1d4, 1d6) plus a Strength modifier.13 RPG sources suggest unarmed damage is typically low.13  
* Damage reduction applied by the target based on a Defense/Toughness attribute or armor soak value (though armor is not relevant here).12 **A simple formula like Damage=(BaseDamage+StrengthMod)−TargetDefenseMod or Damage=BaseDamage×StrengthMultiplier is recommended.** Adding a small random variance (e.g., \+/- 10%) can introduce stochasticity without significant overhead.

**Grappling:** Grappling is a distinct element of unarmed combat.13 If included, rules are needed for:

* *Initiation:* An attack roll to start the grapple.13  
* *Resolution:* Opposed Strength or Agility checks each round to maintain control, escape, or perform actions within the grapple.13  
* *Effects:* Immobilization, inflicting damage, preventing certain actions.13 Grappling significantly increases rule complexity and computational load, especially managing multiple agents grappling a single target.13 **Consider omitting grappling initially or implementing a highly simplified version** (e.g., a single check to temporarily immobilize).

**Defensive Actions:** Agents might have the option to prioritize defense over offense on their turn.12 This could involve:

* *Dodge:* Taking an action to gain a temporary bonus to evasion chance.  
* *Parry/Block:* Taking an action to gain a temporary bonus to damage reduction or defense score. Including defensive options adds tactical depth but also requires agents to have logic for when to use them. **A simple 'Defend' action granting a bonus to the next defense calculation could be included.**

**Critical Hits/Misses:** Introducing a small chance for critical hits (e.g., double damage) or critical misses (e.g., losing next turn) can add variability to the simulation outcomes.12 This is usually implemented based on extreme results of attack rolls or percentage checks. **Optional, but can be added easily if desired.**  
The sheer scale of the 100 vs 1 encounters mandates simplification in these mechanics. Each round, the single entity could potentially face dozens of attack attempts. Resolving each with complex multi-roll mechanics or detailed hit location systems 25 would be computationally infeasible for the 10,000-run script. Similarly, tracking intricate grappling states involving potentially many of the 100 agents against the one 13 becomes prohibitively complex. Therefore, the combat resolution must be streamlined. Simple percentage checks for hits, straightforward damage formulas, and abstracting or simplifying complex maneuvers like grappling are essential. The simulation's focus should be on the statistical aggregation of many simplified interactions rather than the granular detail of each individual blow.27

### **C. Environmental and Group Considerations**

The RoE must also account for the arena environment and the inherent dynamics of the large group versus the individual.  
**Arena Constraints:** The finite, inescapable nature of the arena primarily serves to force combat and limit tactical retreat. Agent movement rules must ensure agents remain within the boundaries. A crucial secondary effect is *crowding*. If agents occupy physical space and cannot overlap, the 100 agents may struggle to all engage the single target simultaneously, especially if melee range is short (e.g., 5 feet 15). This creates a natural bottleneck, limiting the effective application of their numerical superiority. The rules governing movement and agent spacing are therefore critical, even if simple (e.g., grid-based movement, proximity checks).  
**Fatigue:** If realism is desired, a fatigue system can model the effects of exertion over time.8 Fatigue could accumulate with each action taken (attacking, moving) and impose penalties (e.g., reduced speed, lower attack accuracy, decreased damage) once a threshold is reached. However, tracking and applying fatigue for 101 agents adds computational overhead and complexity to agent state management. **It is recommended to either omit fatigue initially or implement a very simple model** (e.g., a global round counter triggering penalties after a certain number of rounds).  
**Basic Group Dynamics (The 100):** While sophisticated coordination or AI-driven tactics are beyond the scope and feasibility of this large-scale simulation, simple rules can capture fundamental group behaviors:

* *Targeting:* The 100 agents will likely target the single opponent. The rule should be explicit: "If the single opponent is within range, attack it."  
* *Movement/Positioning:* Agents need rules to move towards the target if not in range. Basic collision avoidance (preventing agents from occupying the same space) is essential. This implicitly models the crowding effect, potentially limiting how many agents can attack per round. No complex flanking or maneuvering logic is needed.  
* *No Explicit Morale/Command:* The "compelled to engage" constraint eliminates the need for morale checks (agents won't flee) or complex command and control structures often found in military simulations.1

**The Single Entity's Challenge:** The rules should naturally reflect the difficulty of facing overwhelming numbers. This is primarily achieved through the action economy (the single agent likely takes many hits per round) and potentially modified by its defensive capabilities and the emergent crowding effect limiting the attackers.  
The physical constraints of the arena and the simple fact that agents occupy space mean that the 100 agents cannot form an infinitely dense circle around the single target. This *implicit crowding effect* is a crucial emergent factor. The number of agents that can effectively engage the target in melee range at any given time will be limited by geometry and agent spacing rules. This bottleneck significantly influences the larger group's effective damage output per round and is a key dynamic the simulation will reveal. Therefore, the definition of agent size/space and the movement/collision rules within the RoE are critically important components, directly impacting the simulation outcomes.

### **D. Ensuring RoE Applicability for LLM and Scripted Simulations**

A primary challenge is ensuring the RoE is interpreted and applied consistently by both the LLM (across 1,000 runs) and the custom script (across 10,000 runs).  
**Clarity and Precision:** The RoE must be defined using unambiguous language. Terminology should be precise and avoid subjective interpretations. This is vital for the script, which requires exact algorithms, and important for guiding the LLM, minimizing variability in its interpretation of the rules. Vague descriptions will lead to divergent simulation behaviors.  
**Parameterization:** The RoE should be structured so that all key numerical values (e.g., base damage, hit percentages, attribute modifiers, HP values, fatigue thresholds) are explicitly defined as parameters. This allows these values to be easily referenced in LLM prompts and directly implemented as variables or constants in the script, ensuring both methods operate on the same core numerical model.  
**Focus on Mechanics, Not Narrative:** While LLMs excel at narrative generation, the RoE for simulation purposes must prioritize the *mechanics* of how actions are resolved and how the system state changes. Prompts given to the LLM should clearly articulate these mechanics (e.g., "Calculate hit chance using formula X," "Apply damage according to formula Y") rather than relying solely on descriptive prose.  
**Validation Challenge:** It is important to acknowledge the inherent difficulty in verifying that an LLM consistently adheres to a complex set of rules over many runs.1 LLMs can exhibit variability or "hallucinate" behaviors not strictly defined in the prompt. The scripted simulation provides a baseline of mechanically precise execution according to the defined rules. Comparing the statistical distributions of outcomes from the LLM runs and the script runs will be essential. Discrepancies may highlight areas where the LLM's interpretation deviates or where the RoE needs further clarification. Establishing clear standards is crucial for ABMS.28  
To bridge the gap between the potentially narrative-oriented LLM and the algorithm-based script, a highly structured, detailed definition of the RoE is indispensable. This common reference point minimizes the risk of the two methods simulating fundamentally different versions of the combat scenario. The RoE Battle Sheet, detailed in the next section, serves precisely this purpose. It acts as the concrete specification for the script developer and the foundational content for constructing precise LLM prompts, thereby establishing a necessary standard 28 for this dual-method simulation project and ensuring the resulting "modeled statistics" 6 are derived from a consistently defined underlying model.

## **IV. Recommended Rules of Engagement Framework & Battle Sheet**

Based on the analysis of best practices and the specific requirements of the 100 vs 1 simulation, the following RoE framework is recommended, prioritizing computational feasibility, clarity, and cross-method consistency.  
**Synthesized RoE Recommendations:**

* **Combat Flow:** Implement a round-based time advancement system. Use a simple initiative system based on the Speed attribute (highest goes first). Employ a basic action economy allowing one Move action and one Combat Action (e.g., Strike, Defend, simplified Grapple) per agent turn.  
* **Combat Mechanics:** Utilize a single 'Strike' action for unarmed attacks. Resolve attacks using a percentage-based hit chance derived from attacker and defender attributes (e.g., Speed/Agility). Calculate damage using a simple formula involving attacker Strength and target Defense attributes. If included, implement grappling and defensive actions with highly simplified mechanics. Omit complex hit locations or detailed maneuvers.  
* **Environment & Group:** Model the inescapable arena boundaries. Implement basic spatial rules ensuring agents occupy space and cannot overlap, allowing the emergent effect of crowding to naturally limit simultaneous attackers. Use simple targeting logic ("attack the single enemy" for the 100; "attack nearest enemy" for the 1). Omit complex AI, morale, or fatigue unless deemed absolutely essential and implemented simply.

These recommendations strike a balance between capturing the essential dynamics of the mass unarmed combat scenario and ensuring the simulation is computationally tractable for 10,000+ runs and reasonably interpretable by LLMs.  
**The RoE Battle Sheet Template:**  
The following template serves as a definitive specification document. Its purpose is to provide a single, structured source of truth for all parameters and rules governing the simulation. This ensures that both the LLM prompts and the custom script are based on the exact same model definition, facilitating consistency and comparability of results. It translates the conceptual framework into the concrete details needed for implementation.  
**Table 1: RoE Battle Sheet Template**

| Category | Parameter / Rule | Definition / Value / Formula | Notes / Rationale |
| :---- | :---- | :---- | :---- |
| **1\. Simulation Setup** | Arena Dimensions | E.g., 50 ft x 50 ft square | Defines the spatial boundary. Size impacts crowding. |
|  | Time per Round | E.g., 3 simulated seconds | Sets the temporal granularity. |
|  | Victory Condition | Last entity (or side) with HP \> 0 remaining. | Defines the simulation end point. |
| **2\. Agent Attributes** | Health Points (HP) | Max damage capacity. Range: | Core survivability stat. Mutable. |
|  | Strength (STR) | Physical power modifier. Range: | Influences damage output. Immutable base. |
|  | Speed (SPD) | Agility, reflexes modifier. Range: | Influences initiative, hit chance, dodge chance, movement. Immutable base. |
|  | Defense (DEF) | Damage reduction modifier. Range: | Influences damage taken. Immutable base. |
|  | *Other Attributes* | *As needed (e.g., Size, Fatigue Threshold)* | *Define range and effect if included.* |
|  | Attribute Mapping | Guidance on converting character sheet info to numerical values. | Crucial for consistent agent initialization. |
| **3\. Combat Flow** | Initiative Determination | Descending order of SPD attribute value. Ties broken randomly or by pre-defined ID. | Simple, deterministic order. |
|  | Action Economy | 1 Move Action \+ 1 Combat Action per turn. | Balances simplicity and capability. |
| **4\. Combat Actions** | **Move Action** |  |  |
|  | \- Description | Move agent within the arena. | Basic positioning. |
|  | \- Movement Distance | E.g., BaseMove+SPD×UnitDistance per Move Action. | Links Speed to movement capability. |
|  | \- Collision Rule | Agents cannot occupy the same space/tile. Movement path blocked by other agents. | Essential for spatial interaction and crowding. |
|  | **Strike Action** |  | Primary offensive action. |
|  | \- Description | Attempt unarmed attack against adjacent target. | Core combat mechanic. |
|  | \- Targeting | Requires target in adjacent space/within 1 unit distance. | Defines engagement range. |
|  | \- Hit Chance Formula | E.g., Phit​=50%+(AttackerSPD−TargetSPD)×5% (Clamped 5%-95%) | Percentage-based resolution for efficiency. |
|  | \- Damage Formula | E.g., Damage=Max(1,BaseDamage+AttackerSTR−TargetDEF) | Simple damage calculation. Ensure minimum damage. |
|  | \- Parameters | BaseDamage \= \[Value\], Base Hit % \= \[Value\], SPD Modifier % \= \[Value\] | Defines the core numbers for the formulas. |
|  | **Defend Action** | *(Optional)* | Improves survivability. |
|  | \- Description | Agent focuses on defense for one round. | Trades offense for defense. |
|  | \- Effect | E.g., \+\[Value\]% bonus to Dodge Chance or \+\[Value\] to DEF until next turn. | Defines the mechanical benefit. |
|  | **Grapple Action** | *(Optional, Simplified)* | Represents control attempts. |
|  | \- Description | Attempt to immobilize adjacent target. | Simplified version of grappling. |
|  | \- Resolution | E.g., Opposed STR check (Attacker vs Target). Success \= Target Immobilized for 1 round. | Streamlined mechanic. |
| **5\. Other Rules** | Targeting Logic (100 Agents) | Always target the single opposing agent if possible. Move towards it if not in range. | Simple, deterministic behavior for the group. |
|  | Targeting Logic (1 Agent) | Target the nearest agent within range. If multiple equidistant, choose randomly. Move towards nearest if none in range. | Provides a simple heuristic for the single agent. |
|  | Fatigue Rules | *(Optional)* E.g., After \[X\] rounds, agents suffer \-\[Y\] penalty to SPD and STR. | Simple global fatigue effect if needed. |
|  | Critical Hit/Miss | *(Optional)* E.g., Natural 95%+ on hit \= Double Damage. Natural \<5% on hit \= Miss (no other penalty). | Adds stochasticity if desired. |

## **V. Programming Language Recommendation for Custom Simulation**

Selecting the appropriate programming language for the custom CLI script, which will execute the bulk of the simulation runs (10,000), is critical for the project's feasibility and success. The choice directly impacts performance, development time, and the reliability of the results.

### **A. Evaluation Criteria**

The following criteria are essential for evaluating candidate languages for this specific task:

* **Performance:** Raw execution speed is paramount. Simulating 101 agents interacting over potentially many rounds, repeated 10,000 times, is computationally intensive. Faster execution directly translates to shorter analysis cycles.29 CPU efficiency and effective memory management are key components of performance.  
* **Development Time & Ease of Use:** The complexity of the language, the quality of its tooling (compilers, debuggers, IDE support), and the general learning curve affect how quickly the simulation can be implemented, tested, and refined.30 Faster development cycles are always beneficial.  
* **Ecosystem & Libraries:** The availability of mature, well-maintained libraries is crucial. This includes libraries for numerical computation (if complex calculations are needed beyond basic arithmetic), data handling (for loading character sheet data), potentially specialized ABM frameworks, and libraries supporting parallel execution.29 Leveraging existing frameworks can significantly accelerate development.  
* **Scalability & Parallelism:** The ability to efficiently utilize multi-core processors is highly advantageous for reducing the total runtime of the 10,000 simulations. Languages with good built-in support for concurrency and parallelism, or libraries that facilitate it, are preferred.29  
* **Reliability & Safety:** For simulations that may run for extended periods and involve complex state interactions, language features that prevent common programming errors, particularly memory-related issues (leaks, overflows), enhance the reliability of the results and can reduce debugging time.31

### **B. Comparative Analysis of Candidate Languages**

Based on the evaluation criteria, the following languages are considered strong candidates:

* **Python:**  
  * *Pros:* Renowned for its ease of use, readability, and rapid development cycle.30 Possesses an extensive ecosystem, including powerful libraries for data science (NumPy, Pandas) and dedicated ABM frameworks like Mesa and AgentPy.32 Excellent for scripting and prototyping.  
  * *Cons:* Native Python execution speed is generally slower than compiled languages like C++ or Rust, particularly for CPU-intensive loops common in ABM.30 The Global Interpreter Lock (GIL) can limit the effectiveness of thread-based parallelism for CPU-bound tasks.  
  * *Relevance:* A strong contender if development speed is the absolute priority or if the simulation logic relies heavily on existing Python libraries. Performance might be acceptable if the RoE is simple, or if performance-enhancing techniques (e.g., using libraries like Numba, Cython, or PyPy) are employed.  
* **C++:**  
  * *Pros:* Offers exceptional raw performance due to its close-to-hardware nature and highly optimized compilers.29 Provides fine-grained control over memory and system resources. Widely used in high-performance computing, game engines, and some ABM frameworks (e.g., Repast HPC 32, EcoLab 36, Care HPS 36).  
  * *Cons:* Has a significantly steeper learning curve compared to Python.32 Manual memory management is powerful but notoriously error-prone, potentially leading to bugs like memory leaks or segmentation faults that are hard to debug.31 Development cycles are typically longer.  
  * *Relevance:* The traditional choice for performance-critical simulations. Ideal if maximum execution speed is required and the development team possesses strong C++ expertise and is prepared for rigorous memory management.  
* **Rust:**  
  * *Pros:* Delivers performance comparable to C++.31 Its key differentiator is the ownership and borrowing system, which guarantees memory safety and thread safety at compile time without needing a garbage collector.31 This eliminates entire classes of common bugs found in C/C++ (e.g., dangling pointers, data races), significantly enhancing reliability for complex, long-running simulations. Has excellent built-in support for concurrency and parallelism. A dedicated ABM framework, krABMaga, exists.31  
  * *Cons:* The learning curve can be steep, particularly understanding the borrow checker. While the ecosystem is growing rapidly, it may be less mature than C++ or Python in certain niche areas.33  
  * *Relevance:* A compelling modern alternative to C++. Offers top-tier performance combined with strong safety guarantees, making it highly suitable for large-scale, reliable simulations where bugs could invalidate days of computation. The safety features can potentially lead to faster overall development time compared to C++ by reducing debugging effort.  
* **Java:**  
  * *Pros:* Mature language with a vast ecosystem and excellent cross-platform compatibility via the Java Virtual Machine (JVM).29 Strong object-oriented features. Widely used in enterprise systems and supports several established ABM frameworks like Repast Simphony 29, MASON 32, and DESMO-J.37 Automatic garbage collection simplifies memory management compared to C++.  
  * *Cons:* Performance is generally lower than C++ or Rust, especially considering potential garbage collection pauses. Can have higher memory overhead due to the JVM.  
  * *Relevance:* A viable option, particularly if the development team has existing Java expertise or plans to leverage mature Java-based ABM toolkits. However, for a task prioritizing raw speed across 10,000 runs, it's likely outperformed by Rust or C++.  
* **Julia:**  
  * *Pros:* Specifically designed for high-performance technical computing, aiming to bridge the gap between Python's ease of use and C++'s speed.30 Features dynamic typing with excellent performance through just-in-time (JIT) compilation. Strong capabilities for numerical analysis and parallelism. Has an ABM framework, Agents.jl.36  
  * *Cons:* A relatively younger language compared to the others, meaning its ecosystem, tooling, and community size are smaller, although growing.33 Finding experienced developers might be more challenging.  
  * *Relevance:* A very promising language for scientific simulation. If the simulation involves complex mathematical models beyond simple agent rules, Julia could be an excellent fit. Its performance potential is high, but the relative maturity of its ecosystem compared to Rust or C++ for general ABM might be a consideration.

### **C. Language Feature Comparison Table**

To aid in the decision-making process, the table below summarizes the key characteristics of the primary candidate languages against the evaluation criteria.  
**Table 2: Comparison of Candidate Languages for ABM Simulation Script**

| Criterion | Python | C++ | Rust | Julia |
| :---- | :---- | :---- | :---- | :---- |
| **Performance** | Low-Medium (Native) | Very High | Very High | High-Very High |
| **Development Ease** | Very High | Low | Medium-Low | High |
| **Ecosystem / ABM Libs** | Very High (Mesa, AgentPy, NumPy) 36 | High (Repast HPC, General libs) 32 | Medium-High (krABMaga, Growing libs) 31 | Medium (Agents.jl, SciML) 36 |
| **Parallelism Support** | Medium (Limited by GIL for CPU-bound) | High (Requires careful manual implementation) | Very High (Excellent built-in safety) | Very High (Designed for parallelism) |
| **Reliability / Safety** | High (Memory managed) | Low (Manual memory mgmt, error-prone) 31 | Very High (Compile-time memory safety) 31 | High (Memory managed) |

### **D. Final Recommendation and Rationale**

Considering the primary goal of executing 10,000 simulation runs to generate robust statistical data for a potentially complex 100 vs 1 combat scenario, **Rust is recommended as the primary choice for developing the custom CLI script.**  
**Rationale:**

1. **Performance:** The sheer volume of simulation runs necessitates high execution speed. Rust offers performance comparable to C++ 31, ensuring that the 10,000 runs can be completed in a reasonable timeframe. This is likely a significant advantage over Python's native speed.  
2. **Reliability:** Rust's compile-time memory safety guarantees are a major advantage for large-scale, potentially long-running simulations.31 Eliminating common memory-related bugs (like segmentation faults or data races) significantly increases the reliability of the simulation results and can dramatically reduce debugging time compared to C++, where such issues can be subtle and time-consuming to resolve. Ensuring the correctness and stability of the simulation across 10,000 runs is critical for the validity of the statistical analysis.  
3. **Parallelism:** Rust has excellent, safe concurrency features built into the language, making it easier and safer to parallelize the simulation runs across multiple CPU cores, further reducing the total execution time.

**C++** remains a strong secondary option if maximum performance is the *only* consideration and the development team has deep C++ expertise and robust testing/debugging practices in place. However, the inherent risks of manual memory management in complex simulations make Rust's safety features highly attractive.  
**Python** is a viable alternative *only if* development speed is severely constrained *and* the complexity of the RoE and agent interactions is kept relatively low. Using performance-enhancing libraries (Numba, Cython) or alternative interpreters (PyPy) would be essential to mitigate its native speed limitations. However, the cumulative execution time difference over 10,000 runs compared to Rust or C++ is likely to be substantial, potentially impacting the project timeline significantly during the execution phase.  
**Julia** is a promising contender, especially if the simulation requires sophisticated mathematical modeling. However, given its relative youth compared to Rust, the maturity and stability of its ecosystem and tooling for general-purpose ABM might present slightly higher risks for a project requiring high reliability across numerous runs.  
The choice ultimately involves balancing the immediate need for development against the long-term requirements of execution speed and reliability for the extensive simulation campaign. For a project of this scale focused on generating reliable statistics, the initial investment in learning Rust (if necessary) is likely offset by the gains in performance, safety, and reduced debugging effort during the critical execution phase, making it the most robust choice overall.

## **VI. Conclusion**

### **Summary of Recommendations**

This report has provided research-backed recommendations for designing and implementing a large-scale (100 vs 1\) unarmed combat simulation using both LLM and custom script methodologies. The key recommendations are:

1. **Adopt Agent-Based Modeling (ABM):** Utilize ABM as the core paradigm to capture the complexity, emergent behavior, and heterogeneity inherent in the scenario.  
2. **Implement a Streamlined RoE Framework:** Structure the Rules of Engagement based on simplicity and computational feasibility. This includes round-based time, Speed-based initiative, a basic action economy (Move \+ Combat Action), percentage-based attack resolution, simple damage formulas, basic spatial constraints (arena boundaries, non-overlapping agents), and simple targeting logic. Omit or highly simplify complex mechanics like detailed grappling or fatigue unless absolutely essential.  
3. **Utilize the RoE Battle Sheet:** Employ the provided RoE Battle Sheet template as the definitive specification for all simulation parameters and rules. This ensures consistency between the LLM prompts and the custom script implementation, acting as the crucial link for comparability.  
4. **Select Rust for the Custom Script:** Develop the high-volume (10,000 run) CLI simulation using the Rust programming language. Its combination of C++-level performance, compile-time memory safety guarantees, and excellent concurrency support makes it the most suitable choice for ensuring both speed and reliability in this large-scale simulation task. C++ is a viable alternative if performance is the sole driver and safety risks are managed. Python should only be considered if development time is extremely limited and RoE complexity is low.

### **Reinforcement of Rationale**

These recommendations are designed to directly support the user's goal of obtaining reliable, modeled statistics on the outcome of the 100 vs 1 combat scenario. The ABM approach allows for the necessary granularity and captures emergent dynamics. The simplified RoE framework ensures computational tractability for the 10,000 scripted runs while providing a clear mechanical basis that can also be communicated to LLMs. The RoE Battle Sheet enforces consistency across the dual simulation methods. The choice of Rust prioritizes the performance and reliability crucial for executing the large number of runs required for robust statistical analysis, mitigating risks associated with bugs or excessive runtimes. This integrated approach balances the need for adequate model fidelity with the practical constraints of large-scale simulation.

### **Next Steps**

With these recommendations, the user can proceed with the following steps:

1. **Finalize the RoE Battle Sheet:** Populate the template with specific parameter values derived from the intended character sheets and desired simulation balance.  
2. **Develop Simulation Prototypes:** Implement a small-scale version of the simulation using the recommended language (Rust) to test the core mechanics and performance characteristics. Concurrently, develop and refine prompts for the LLM based on the RoE Battle Sheet.  
3. **Implement the Full Simulation:** Develop the complete CLI script in Rust and finalize the LLM prompting strategy.  
4. **Validation and Calibration:** Run initial batches of simulations with both methods. Compare the output distributions and analyze any significant discrepancies. Adjust parameters or clarify RoE definitions as needed to improve consistency or desired behavior. Perform sensitivity analysis by varying key parameters on the Battle Sheet.  
5. **Execute Full Simulation Campaign:** Run the 1,000 LLM simulations and 10,000 scripted simulations.  
6. **Analyze Results:** Process the output data to generate statistical summaries, determine the likely victor under the modeled conditions, and identify key factors influencing the outcomes.

### **Final Thought**

The simulation of a 100 vs 1 unarmed combat scenario presents a fascinating challenge in modeling complex system dynamics. By carefully designing the simulation based on the principles of Agent-Based Modeling, employing a well-defined and computationally feasible Rules of Engagement framework, and selecting a high-performance, reliable programming language, the user will be well-equipped to generate meaningful statistical insights. The results can illuminate the intricate interplay between individual capabilities, numerical advantage, spatial constraints, and emergent group behavior in extreme combat situations.

#### **Works cited**

1. Agent-Based Modeling in Defense \- SmythOS, accessed May 3, 2025, [https://smythos.com/ai-industry-solutions/government/agent-based-modeling-in-defense/](https://smythos.com/ai-industry-solutions/government/agent-based-modeling-in-defense/)  
2. Military applications of agent-based simulations \- ResearchGate, accessed May 3, 2025, [https://www.researchgate.net/publication/4111830\_Military\_applications\_of\_agent-based\_simulations](https://www.researchgate.net/publication/4111830_Military_applications_of_agent-based_simulations)  
3. AGENT-BASED MODELING AND SIMULATION \- WSC Archive, accessed May 3, 2025, [https://www.informs-sim.org/wsc09papers/009.pdf](https://www.informs-sim.org/wsc09papers/009.pdf)  
4. Agent-based model \- Wikipedia, accessed May 3, 2025, [https://en.wikipedia.org/wiki/Agent-based\_model](https://en.wikipedia.org/wiki/Agent-based_model)  
5. Considerations and Best Practices in Agent-Based Modeling to Inform Policy \- NCBI, accessed May 3, 2025, [https://www.ncbi.nlm.nih.gov/books/NBK305917/](https://www.ncbi.nlm.nih.gov/books/NBK305917/)  
6. RPG Stats: Implementing Character Stats in Video Games \- How to Make an RPG, accessed May 3, 2025, [https://howtomakeanrpg.com/r/a/how-to-make-an-rpg-stats.html](https://howtomakeanrpg.com/r/a/how-to-make-an-rpg-stats.html)  
7. What makes a good set of Attributes? : r/RPGdesign \- Reddit, accessed May 3, 2025, [https://www.reddit.com/r/RPGdesign/comments/10dg10y/what\_makes\_a\_good\_set\_of\_attributes/](https://www.reddit.com/r/RPGdesign/comments/10dg10y/what_makes_a_good_set_of_attributes/)  
8. RPG Character Attributes Scores | Tabletop Roleplaying Game Design \- RPGnet Forums, accessed May 3, 2025, [https://forum.rpg.net/index.php?threads/rpg-character-attributes-scores.749878/](https://forum.rpg.net/index.php?threads/rpg-character-attributes-scores.749878/)  
9. Design Decisions: Attributes \- Living Myth Design Rpg \- WordPress.com, accessed May 3, 2025, [https://livingmythrpg.wordpress.com/2019/04/20/design-decisions-attributes/](https://livingmythrpg.wordpress.com/2019/04/20/design-decisions-attributes/)  
10. Think Before You Stat \- Storybrewers Roleplaying, accessed May 3, 2025, [https://storybrewersroleplaying.com/2017/05/30/think-before-you-stat/](https://storybrewersroleplaying.com/2017/05/30/think-before-you-stat/)  
11. Attributes for a generic RPG | Tabletop Roleplaying Game Design | RPGnet Forums, accessed May 3, 2025, [https://forum.rpg.net/index.php?threads/attributes-for-a-generic-rpg.28973/](https://forum.rpg.net/index.php?threads/attributes-for-a-generic-rpg.28973/)  
12. Designing a fast and deadly melee combat system. : r/tabletopgamedesign \- Reddit, accessed May 3, 2025, [https://www.reddit.com/r/tabletopgamedesign/comments/sfvuyr/designing\_a\_fast\_and\_deadly\_melee\_combat\_system/](https://www.reddit.com/r/tabletopgamedesign/comments/sfvuyr/designing_a_fast_and_deadly_melee_combat_system/)  
13. Unarmed Combat\! \- Mazirian's Garden, accessed May 3, 2025, [http://maziriansgarden.blogspot.com/2021/03/unarmed-combat.html](http://maziriansgarden.blogspot.com/2021/03/unarmed-combat.html)  
14. Combat in Seconds Revised | Tabletop Roleplaying Game Design \- RPGnet Forums, accessed May 3, 2025, [https://forum.rpg.net/index.php?goto/post\&id=25099997](https://forum.rpg.net/index.php?goto/post&id=25099997)  
15. Flurry of blows while armed \- Homebrew & House Rules \- Dungeons & Dragons Discussion, accessed May 3, 2025, [https://www.dndbeyond.com/forums/dungeons-dragons-discussion/homebrew-house-rules/219788-flurry-of-blows-while-armed](https://www.dndbeyond.com/forums/dungeons-dragons-discussion/homebrew-house-rules/219788-flurry-of-blows-while-armed)  
16. Making Unarmed and Melee mechanically distinct? \- RPG Codex, accessed May 3, 2025, [https://rpgcodex.net/forums/threads/making-unarmed-and-melee-mechanically-distinct.149583/](https://rpgcodex.net/forums/threads/making-unarmed-and-melee-mechanically-distinct.149583/)  
17. Unarmed combat ruling : r/DMAcademy \- Reddit, accessed May 3, 2025, [https://www.reddit.com/r/DMAcademy/comments/s3pn3h/unarmed\_combat\_ruling/](https://www.reddit.com/r/DMAcademy/comments/s3pn3h/unarmed_combat_ruling/)  
18. Agent-Based Simulation of Time to Decide, accessed May 3, 2025, [https://www.jasss.org/18/4/10.html](https://www.jasss.org/18/4/10.html)  
19. Modeling the Information Age Combat Model: An Agent-Based Simulation of Network Centric Operations, accessed May 3, 2025, [https://ntrs.nasa.gov/api/citations/20100012866/downloads/20100012866.pdf](https://ntrs.nasa.gov/api/citations/20100012866/downloads/20100012866.pdf)  
20. Evolution of Discrete Event Simulation Software | Simio, accessed May 3, 2025, [https://www.simio.com/evolution-of-discrete-event-simulation-software/](https://www.simio.com/evolution-of-discrete-event-simulation-software/)  
21. A History of Discrete Event Simulation Programming Languages \- Nance, accessed May 3, 2025, [https://pdes-course-2014.llnl.gov/attachments/20776356/24674625.pdf](https://pdes-course-2014.llnl.gov/attachments/20776356/24674625.pdf)  
22. A History of Discrete Event Simulation Programming Languages \- Computer Science Technical Reports, accessed May 3, 2025, [https://eprints.cs.vt.edu/archive/00000363/01/TR-93-21.pdf](https://eprints.cs.vt.edu/archive/00000363/01/TR-93-21.pdf)  
23. George S. Fishman: Discrete-Event Simulation, accessed May 3, 2025, [https://www.jasss.org/5/3/reviews/jaramillo.html](https://www.jasss.org/5/3/reviews/jaramillo.html)  
24. What are the practical differences between discrete and continuous simulations?, accessed May 3, 2025, [https://gamedev.stackexchange.com/questions/136824/what-are-the-practical-differences-between-discrete-and-continuous-simulations](https://gamedev.stackexchange.com/questions/136824/what-are-the-practical-differences-between-discrete-and-continuous-simulations)  
25. Combat Melee \- Playtank, accessed May 3, 2025, [https://playtank.io/2024/08/12/building-systemic-melee/](https://playtank.io/2024/08/12/building-systemic-melee/)  
26. DISCRETE EVENT SIMULATION LANGUAGES \- Charles M. Shub, accessed May 3, 2025, [https://informs-sim.org/wsc80papers/1980\_0045.pdf](https://informs-sim.org/wsc80papers/1980_0045.pdf)  
27. Can you do Dual wielding unarmed? \- FFG Forum Archive, accessed May 3, 2025, [https://ffg-forum-archive.entropicdreams.com/topic/193239-can-you-do-dual-wielding-unarmed/page/2/](https://ffg-forum-archive.entropicdreams.com/topic/193239-can-you-do-dual-wielding-unarmed/page/2/)  
28. A Call to Arms \- Journal of Artificial Societies and Social Simulation, accessed May 3, 2025, [https://jasss.soc.surrey.ac.uk/18/3/12.html](https://jasss.soc.surrey.ac.uk/18/3/12.html)  
29. Agent-Based Modeling Programming Languages \- SmythOS, accessed May 3, 2025, [https://smythos.com/ai-agents/ai-agent-development/agent-based-modeling-programming-languages/](https://smythos.com/ai-agents/ai-agent-development/agent-based-modeling-programming-languages/)  
30. How to learn agent-based modelling/simulation, and what programming language would I need to learn \- Quora, accessed May 3, 2025, [https://www.quora.com/How-do-you-learn-agent-based-modelling-simulation-and-what-programming-language-would-I-need-to-learn](https://www.quora.com/How-do-you-learn-agent-based-modelling-simulation-and-what-programming-language-would-I-need-to-learn)  
31. Reliable and Efficient Agent-Based Modeling and Simulation, accessed May 3, 2025, [https://www.jasss.org/27/2/4.html](https://www.jasss.org/27/2/4.html)  
32. A good software for agent based modelling? \- Biology Stack Exchange, accessed May 3, 2025, [https://biology.stackexchange.com/questions/44614/a-good-software-for-agent-based-modelling](https://biology.stackexchange.com/questions/44614/a-good-software-for-agent-based-modelling)  
33. Language for simulations and agent-based modeling, plus one problem \- Reddit, accessed May 3, 2025, [https://www.reddit.com/r/ProgrammingLanguages/comments/jap67u/language\_for\_simulations\_and\_agentbased\_modeling/](https://www.reddit.com/r/ProgrammingLanguages/comments/jap67u/language_for_simulations_and_agentbased_modeling/)  
34. Software for Agent-Based Computational Economics and Complex Adaptive Systems (Tesfatsion) \- Faculty Website Directory, accessed May 3, 2025, [https://faculty.sites.iastate.edu/tesfatsi/archive/tesfatsi/acecode.htm](https://faculty.sites.iastate.edu/tesfatsi/archive/tesfatsi/acecode.htm)  
35. Which programming environment is best used for agent-based modelling of land-use systems, including GIS integration? | ResearchGate, accessed May 3, 2025, [https://www.researchgate.net/post/Which\_programming\_environment\_is\_best\_used\_for\_agent-based\_modelling\_of\_land-use\_systems\_including\_GIS\_integration](https://www.researchgate.net/post/Which_programming_environment_is_best_used_for_agent-based_modelling_of_land-use_systems_including_GIS_integration)  
36. Agent-Based Models and Simulations Tools \- Encyclopedia.pub, accessed May 3, 2025, [https://encyclopedia.pub/entry/40674](https://encyclopedia.pub/entry/40674)  
37. List of discrete event simulation software \- Wikipedia, accessed May 3, 2025, [https://en.wikipedia.org/wiki/List\_of\_discrete\_event\_simulation\_software](https://en.wikipedia.org/wiki/List_of_discrete_event_simulation_software)